% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/configure_smashy.R
\name{configure_smashy}
\alias{configure_smashy}
\title{Configure Full Smashy Optimizer.}
\usage{
configure_smashy(
  search_space,
  budget_log_step,
  mu,
  survival_fraction = 1/3,
  sample = "bohb",
  batch_method = "smashy",
  filter_algorithm = "tournament",
  surrogate_learner = "knn1",
  filter_with_max_budget = TRUE,
  filter_factor_first = 100,
  filter_factor_last = filter_factor_first,
  filter_select_per_tournament = 1,
  random_interleave_fraction = 1/3,
  filter_factor_first.end = filter_factor_first,
  filter_factor_last.end = filter_factor_last,
  filter_select_per_tournament.end = filter_select_per_tournament,
  random_interleave_fraction.end = random_interleave_fraction,
  random_interleave_random = TRUE,
  budget_is_logscale = FALSE,
  type = "Optimizer"
)
}
\arguments{
\item{search_space}{(\code{\link[paradox:ParamSet]{ParamSet}})\cr
search space, has one parameter tagged 'budget'.}

\item{budget_log_step}{(\code{numeric(1)})\cr
\code{log()} of budget fidelity steps to make. E.g. \code{log(2)} for doubling. Must always be on log scale,
even when \code{budget_is_logscale} is \code{FALSE}.}

\item{mu}{(\code{integer(1)})\cr
Population size, must be at least 2.}

\item{survival_fraction}{(\code{numeric(1)})\cr
Fraction of individuals that survive each round. Must be between 0 and 1. If \code{mu} is very large,
it is decreased so that \code{round(mu * survival_fraction)} is < \code{survival_fraction}. Defaults to \code{1 / 3}.}

\item{sample}{(\code{character(1)})\cr
Sampling mechanism: Must be either \code{"random"} (sample uniformly at random), or \code{"bohb"} (use
BOHB sampling from kernel density estimate of well performing points). Default \code{"bohb"}.}

\item{batch_method}{(\code{character(1)})\cr
Fidelity schedule, one of \code{"smashy"} or \code{"hb"}. \code{"smashy"} uses synchronized batches, \code{"hb"}
does scheduling similar to Hyperband, but generalized for possibly disagreeing values of
\code{budget_log_step} and \code{survival_fraction}. For true Hyperband (up to rounding), set \code{budget_log_step} to
\code{log(survival_fraction)} and \code{mu} to \code{survival_fraction ^ -fidelity_steps} (where \code{fidelity_steps}
counts from 0 for "no step, only highest budget is evaluated"). Defaults to \code{"smashy"}.}

\item{filter_algorithm}{(\code{character(1)})\cr
One of \code{"tournament"} (using \code{\link{FiltorSurrogateTournament}}) or \code{"progressive"}
(using \code{\link{FiltorSurrogateProgressive}}). Defaults to \code{"tournament"}.}

\item{surrogate_learner}{(\code{character(1)})\cr
Surrogate learner to use for filtering. One of \code{"knn1"}, \code{"knn7"} (KNN with \code{k} = 1 or \code{k} = 7, respectively),
\code{"ranger"} (random forest) or \code{"bohblrn"} (emulating the TPE used in the BOHB paper). Defaults to \code{"knn1"}.}

\item{filter_with_max_budget}{(\code{logical(1)})\cr
Whether to use the surrogate learner to predict performance at the maximum budget value that has been
evaluated thus far, or at the budget value being currently evaluated. Behavour of these only disagrees
once at least one full-budget configuration has been evaluated. Default \code{TRUE}.}

\item{filter_factor_first}{(\code{numeric(1)})\cr
When filtering the first configuration using the \code{\link{FiltorSurrogateTournament}} or \code{\link{FiltorSurrogateProgressive}},
how many random samples to consider. Corresponds to \code{filter.tournament_size/filter.per_tournament} in
\code{\link{FiltorSurrogateTournament}}
and \code{filter.pool_factor} in \code{\link{FiltorSurrogateProgressive}}. Default 100.\cr
Note the \emph{Simulated Annealing} section about \code{filter_factor_first.end}.}

\item{filter_factor_last}{(\code{numeric(1)})\cr
When filtering the last configuration using the \code{\link{FiltorSurrogateTournament}} or \code{\link{FiltorSurrogateProgressive}},
how many random samples to consider. Corresponds to \code{filter.tournament_size_last/filter.per_tournament} in
\code{\link{FiltorSurrogateTournament}}
and \code{filter.pool_factor_last} in \code{\link{FiltorSurrogateProgressive}}. Default to the value given to
\code{filter_factor_first}.
Note the \emph{Simulated Annealing} section about \code{filter_factor_last.end}.}

\item{filter_select_per_tournament}{(\code{integer(1)})\cr
Only when \code{filter_algorithm} is \code{"tournament"}: How many configurations to draw per tournament. Corresponds
to \code{filter.per_tournament} of \code{\link{FiltorSurrogateTournament}}. Must be at least 1. Defaults to 1.
Note the \emph{Simulated Annealing} section about \code{filter_select_per_tournament.end}.}

\item{random_interleave_fraction}{(\code{numeric(1)})\cr
How many configurations to not filter using the surrogate in each generation and to instead draw
randomly using the \code{sample} method. Must be between 0 and 1, where a value of 1 means no surrogate-based filtering
is done at all, all values are drawn randomly. Defaults to \code{1 / 3}.\cr
Note the \emph{Simulated Annealing} section about \code{random_interleave_fraction.end}.}

\item{filter_factor_first.end}{(\code{numeric(1)})\cr
Corresponds to \code{filter_factor_first}, see the \emph{Simulated Annealing} section.}

\item{filter_factor_last.end}{(\code{numeric(1)})\cr
Corresponds to \code{filter_factor_last}, see the \emph{Simulated Annealing} section.}

\item{filter_select_per_tournament.end}{(\code{integer(1)})\cr
Corresponds to \code{filter_select_per_tournament}, see the \emph{Simulated Annealing} section.}

\item{random_interleave_fraction.end}{(\code{numeric(1)})\cr
Corresponds to \code{random_interleave_fraction}, see the \emph{Simulated Annealing} section.}

\item{random_interleave_random}{(\code{logical(1)})\cr
Whether during each sampling, a fixed fraction of \code{random_interleave_fraction} individuals
is drawn randomly (\code{FALSE}), or the number of individuals to draw randomly is itself random (\code{TRUE}).
In the latter case, each new configuration has an independent chance of being drawn randomly with
probability \code{random_interleave_fraction}. Default \code{TRUE}.}

\item{budget_is_logscale}{(\code{logical(1)})\cr
Whether the component of \code{search_space} tagged as \code{"budget"} is in log-scale (\code{TRUE}) or not (\code{FALSE}).
When \code{budget_is_logscale} is given as \code{TRUE}, then evaluations are done with linear steps of \code{budget_log_step}.
Otherwise, exponential steps of \code{exp(budget_log_step)} are performed. Default \code{FALSE}.}

\item{type}{(\code{character(1)})\cr
One of \code{"Optimizer"} or \code{"Tuner"}. What class to return: An \code{\link[bbotk:Optimizer]{Optimizer}} for
optimizing \code{\link[bbotk:OptimInstanceSingleCrit]{OptimInstanceSingleCrit}} objects, or a
\code{\link[mlr3tuning:Tuner]{Tuner}} for tuning \code{\link[mlr3:Learner]{mlr3::Learner}}s. Defaults to \code{"Optimizer"}.}
}
\value{
\code{\link{OptimizerSmashy}} or \code{\link{TunerSmashy}}, depending on the \code{type} argument: The configured \emph{Smashy} optimizer.
}
\description{
Create a \code{\link{OptimizerSmashy}} (or \code{\link{TunerSmashy}}) object with extended functionality from
basic building blocks. While basic Smashy-optimizers can be created with \code{opt("smashy")}
and \code{tnr("smashy")}, setting them up for functionality such as BOHB-like surrogate
model filtering or change of filter configuration over the course of optimization
can be difficult, hence this helper function. \code{configure_smashy()} should be used
when the extended functionality is desired.
}
\section{Simulated Annealing}{

For the function arguments \code{filter_factor_first}, \code{filter_factor_last},
\code{select_per_tournament}, and \code{random_interleave_fraction}, it is possible to also give
corresponding \verb{*.end} arguments.
When the corresponding \verb{*.end} argument differs from the given value, then the effective
value changes over the course of optimization, starting at the given value and progressing
geometrically (for \code{filter_factor_first}, \code{filter_factor_last}, and \code{select_per_tournament}) or
linearly (for \code{random_interleave_fraction}) towards the \verb{*.end}-value at the end.
}

\examples{
library("bbotk")

# Define the objective to optimize
# The 'budget' here simulates averaging 'b' samples from a noisy function
objective <- ObjectiveRFun$new(
  fun = function(xs) {
    z <- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    z <- z + rnorm(1, sd = 1 / sqrt(xs$b))
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4), b = p_int(1)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

search_space = objective$domain$search_space(list(
  x = to_tune(),
  y = to_tune(),
  b = to_tune(p_int(1, 2^10, tags = "budget"))
))

# Get a new OptimInstance. Here we determine that the optimizatoin goes
# for 100 full budget evaluations (100 * 2^100)
oi <- OptimInstanceSingleCrit$new(objective,
  search_space = search_space,
  terminator = trm("budget", budget = 10 * 2^10)
)

# smashy is designed with parallel evaluation in mind. It is
# recommended to run
# > future::plan("multisession") (windows, or in RStudio)
# or
# > future::plan("multicore") (Linux without RStudio)
# and then set `mu` to a multiple of the number of CPU cores.

smashy = configure_smashy(search_space, budget_log_step = log(4), mu = 6)

smashy$optimize(oi)

}
