% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/configure_smashy.R
\name{smashy_as_hyperband}
\alias{smashy_as_hyperband}
\title{Emulate the Hyperband optimizer.}
\usage{
smashy_as_hyperband(
  search_space,
  eta = 3,
  budget_is_logscale = FALSE,
  type = "Optimizer"
)
}
\arguments{
\item{search_space}{(\code{\link[paradox:ParamSet]{ParamSet}})\cr
search space, has one parameter tagged 'budget'.}

\item{eta}{(\code{numeric(1)})\cr
Eta-parameter of Hyperband:
Factor of budget increase and at the same time, one over fraction of configurations that survive, for
each batch evaluation. Default 3.}

\item{budget_is_logscale}{(\code{logical(1)})\cr
Whether the component of \code{search_space} tagged as \code{"budget"} is in log-scale (\code{TRUE}) or not (\code{FALSE}).
When \code{budget_is_logscale} is given as \code{TRUE}, then evaluations are done with linear steps of \code{budget_log_step}.
Otherwise, exponential steps of \code{exp(budget_log_step)} are performed. Default \code{FALSE}.}

\item{type}{(\code{character(1)})\cr
One of \code{"Optimizer"} or \code{"Tuner"}. What class to return: An \code{\link[bbotk:Optimizer]{Optimizer}} for
optimizing \code{\link[bbotk:OptimInstanceSingleCrit]{OptimInstanceSingleCrit}} objects, or a
\code{\link[mlr3tuning:Tuner]{Tuner}} for tuning \code{\link[mlr3:Learner]{mlr3::Learner}}s. Defaults to \code{"Optimizer"}.}
}
\value{
\code{\link{OptimizerSmashy}} or \code{\link{TunerSmashy}}, depending on the \code{type} argument: The configured \emph{Smashy} optimizer.
}
\description{
Create a \code{\link{OptimizerSmashy}} (or \code{\link{TunerSmashy}}) object which behaves as
the Hyperband optimizer presented by Li et al. (2018).
}
\examples{
library("bbotk")

# Define the objective to optimize
# The 'budget' here simulates averaging 'b' samples from a noisy function
objective <- ObjectiveRFun$new(
  fun = function(xs) {
    z <- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    z <- z + rnorm(1, sd = 1 / sqrt(xs$b))
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4), b = p_int(1)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

search_space = objective$domain$search_space(list(
  x = to_tune(),
  y = to_tune(),
  b = to_tune(p_int(1, 2^10, tags = "budget"))
))

# Get a new OptimInstance. Here we determine that the optimizatoin goes
# for 100 full budget evaluations (100 * 2^100)
oi <- OptimInstanceSingleCrit$new(objective,
  search_space = search_space,
  terminator = trm("budget", budget = 100 * 2^10)
)

hb = smashy_as_hyperband(search_space)

hb$optimize(oi)

}
